* Test-driven developed RoboGraphics drawing program
** BUILDING
   This project uses [[https://gradle.org/][gradle]] for building and running tests.
   To build the project run gradle with the *build* argument:
#+begin_src sh 
gradle build
#+end_src 
   To generate a runnable jar file, also call the *jar* argument:
#+begin_src sh 
gradle build jar
#+end_src 
   All class and jar files generated by gradle are stored in the [[file:./build/][build]] directory.
** RUNNING TESTS
   To run tests using gradle, use the *test* argument to gradle:
#+begin_src sh 
gradle test
#+end_src 
   This will run all tests and print any tests that generate output, errors or stdout.
   To see a more complete overview of all tests run, consult the [[file:./build/reports/tests/test/index.html][build/reports/tests/test/index.html]] file
   generated from running the *test* command.
** About the program
   This entire program has been programmed in a functional style,
   putting emphasis on composablility and stream evaluation.
*** FileHandler
    The file handler interface implements everything specified by the task,
    and an extra method called *lines()*, which matches the functionality of [[https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--][BufferedReader::lines()]].
    This turns out to be very useful later on when applying CommandReader
*** Command
    A command here is a *@FunctionalInterface*, in otherwords it can be written as a function.
    The *Command* interface returns an [[https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html][java.util.Optional]] of *Exception*,
    which represents the result of the computation of the command,
    the command returns an Exception if it fails to execute.
    This makes handling errors in stream A LOT easier.
*** CommandReader
    In all essense the *CommandReader* class could itself be represented as a function from String -> Command.
    As such really the only things the CommandReader class needs is a static method to parse the command,
    this is static because the space of valid commands does not change for each instance.
    Thus the only non static method needed except for the constructor is the *commands()* method,
    which uses the underlying FileHandlers *lines()* stream,
    and simply maps the *parseCommand(String)* function over each line.
    If the line cannot be parsed to a command *parseCommand*, it returns *Optional.empty()*,
    which is never executed.
    If we wanted error checking in *CommandReader* we would change the return to be something like,
    *Either<Command,Exception>*, instead of an optional.
    Java does not contain an *Either<T,K>* class by default (there is one in javaslang),
    but you can implement it fairly easily using *Optional*,
    see [[http://stackoverflow.com/questions/26162407/is-there-an-equivalent-of-scalas-either-in-java-8#26164155][this answer on stackoverflow]] for an example.
*** RoboGraphics
    This does the bulk of the work, but also in essense is only a "function"
    that maps a stream of commands to a character matrix.
    This contains the control logic for each Command, and handles returning errors.
    Usage from the outside should mostly be limited to the *execute*, helper function,
    which applies commands to itself, and returns the result of executing them.
    It also has a *executeFromReader* function that uses the *CommandReader* 
    passed in the constructor and executes all the commands it gets from *CommandReader::commands()*.
    
    The *final char BLANK_CELL*, specifies what to initialize the canvas matrix with,
    and also what to use when checking if we can draw in a cell.
